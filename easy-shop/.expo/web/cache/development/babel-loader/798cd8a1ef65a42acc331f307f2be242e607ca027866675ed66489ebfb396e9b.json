{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _jsxFileName = 'src/basic/Tabs/index.js';\nvar _propTypes = require('prop-types');\nvar _propTypes2 = _interopRequireDefault(_propTypes);\nvar _createReactClass = require('create-react-class');\nvar _createReactClass2 = _interopRequireDefault(_createReactClass);\nvar _lodash = require('lodash');\nvar _lodash2 = _interopRequireDefault(_lodash);\nvar _utils = require(\"../../utils\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar React = require('react');\nvar Component = React.Component;\nvar ReactNative = require(\"react-native-web/dist/index\");\nvar Dimensions = ReactNative.Dimensions,\n  View = ReactNative.View,\n  Animated = ReactNative.Animated,\n  ScrollView = ReactNative.ScrollView,\n  StyleSheet = ReactNative.StyleSheet,\n  Platform = ReactNative.Platform;\nvar SceneComponent = require(\"./SceneComponent\");\nvar _require = require(\"./DefaultTabBar\"),\n  DefaultTabBar = _require.DefaultTabBar;\nvar _require2 = require(\"./ScrollableTabBar\"),\n  ScrollableTabBar = _require2.ScrollableTabBar;\nvar ScrollableTabView = (0, _createReactClass2.default)({\n  displayName: 'ScrollableTabView',\n  statics: {\n    DefaultTabBar: DefaultTabBar,\n    ScrollableTabBar: ScrollableTabBar\n  },\n  propTypes: {\n    tabBarPosition: _propTypes2.default.oneOf(['top', 'bottom', 'overlayTop', 'overlayBottom']),\n    initialPage: _propTypes2.default.number,\n    page: _propTypes2.default.number,\n    onChangeTab: _propTypes2.default.func,\n    onScroll: _propTypes2.default.func,\n    renderTabBar: _propTypes2.default.any,\n    style: _utils.ViewPropTypes.style,\n    contentProps: _propTypes2.default.object,\n    scrollWithoutAnimation: _propTypes2.default.bool,\n    locked: _propTypes2.default.bool,\n    prerenderingSiblingsNumber: _propTypes2.default.number\n  },\n  getDefaultProps: function getDefaultProps() {\n    return {\n      tabBarPosition: 'top',\n      initialPage: 0,\n      page: -1,\n      onChangeTab: function onChangeTab() {},\n      onScroll: function onScroll() {},\n      contentProps: {},\n      scrollWithoutAnimation: false,\n      locked: false,\n      prerenderingSiblingsNumber: 0\n    };\n  },\n  getInitialState: function getInitialState() {\n    return {\n      currentPage: this.props.initialPage,\n      scrollValue: new Animated.Value(this.props.initialPage),\n      containerWidth: Dimensions.get('window').width,\n      sceneKeys: this.newSceneKeys({\n        currentPage: this.props.initialPage\n      })\n    };\n  },\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n    var scrollFn = function scrollFn() {\n      if (_this.scrollView) {\n        _this.state.scrollValue.setValue(_this.props.initialPage);\n      }\n    };\n    _utils.InteractionManager.runAfterInteractions(scrollFn);\n    this.scrollToTimer = setTimeout(function () {\n      if (_this.scrollView) {\n        _this.scrollView.scrollTo({\n          x: _this.props.initialPage * _this.state.containerWidth,\n          animated: false\n        });\n      }\n    });\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    if (this.scrollToTimer) {\n      clearTimeout(this.scrollToTimer);\n    }\n  },\n  UNSAFE_componentWillReceiveProps: function UNSAFE_componentWillReceiveProps(props) {\n    if (props.children !== this.props.children) {\n      this.updateSceneKeys({\n        page: this.state.currentPage,\n        children: props.children\n      });\n    }\n    if (props.page >= 0 && props.page !== this.state.currentPage) {\n      this.goToPage(props.page);\n    }\n  },\n  goToPage: function goToPage(pageNumber) {\n    var offset = pageNumber * this.state.containerWidth;\n    if (this.scrollView) {\n      this.scrollView.scrollTo({\n        x: offset,\n        y: 0,\n        animated: !this.props.scrollWithoutAnimation\n      });\n    }\n    var currentPage = this.state.currentPage;\n    this.updateSceneKeys({\n      page: pageNumber,\n      callback: this._onChangeTab.bind(this, currentPage, pageNumber)\n    });\n  },\n  renderTabBar: function renderTabBar(props) {\n    if (this.props.renderTabBar === false) {\n      return null;\n    } else if (this.props.renderTabBar) {\n      return React.cloneElement(this.props.renderTabBar(props), props);\n    }\n    return React.createElement(DefaultTabBar, _extends({}, props, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 129\n      }\n    }));\n  },\n  updateSceneKeys: function updateSceneKeys(_ref) {\n    var page = _ref.page,\n      _ref$children = _ref.children,\n      children = _ref$children === undefined ? this.props.children : _ref$children,\n      _ref$callback = _ref.callback,\n      callback = _ref$callback === undefined ? function () {} : _ref$callback;\n    var newKeys = this.newSceneKeys({\n      previousKeys: this.state.sceneKeys,\n      currentPage: page,\n      children: children\n    });\n    this.setState({\n      currentPage: page,\n      sceneKeys: newKeys\n    }, callback);\n  },\n  newSceneKeys: function newSceneKeys(_ref2) {\n    var _this2 = this;\n    var _ref2$previousKeys = _ref2.previousKeys,\n      previousKeys = _ref2$previousKeys === undefined ? [] : _ref2$previousKeys,\n      _ref2$currentPage = _ref2.currentPage,\n      currentPage = _ref2$currentPage === undefined ? 0 : _ref2$currentPage,\n      _ref2$children = _ref2.children,\n      children = _ref2$children === undefined ? this.props.children : _ref2$children;\n    var newKeys = [];\n    this._children(children).forEach(function (child, idx) {\n      var key = _this2._makeSceneKey(child, idx);\n      if (_this2._keyExists(previousKeys, key) || _this2._shouldRenderSceneKey(idx, currentPage)) {\n        newKeys.push(key);\n      }\n    });\n    return newKeys;\n  },\n  _shouldRenderSceneKey: function _shouldRenderSceneKey(idx, currentPageKey) {\n    var numOfSibling = this.props.prerenderingSiblingsNumber;\n    return idx < currentPageKey + numOfSibling + 1 && idx > currentPageKey - numOfSibling - 1;\n  },\n  _keyExists: function _keyExists(sceneKeys, key) {\n    return sceneKeys.find(function (sceneKey) {\n      return key === sceneKey;\n    });\n  },\n  _makeSceneKey: function _makeSceneKey(child, idx) {\n    return child.props.heading + '_' + idx;\n  },\n  renderScrollableContent: function renderScrollableContent() {\n    var _this3 = this;\n    var scenes = this._composeScenes();\n    return React.createElement(ScrollView, _extends({\n      horizontal: true,\n      pagingEnabled: true,\n      automaticallyAdjustContentInsets: false,\n      keyboardShouldPersistTaps: 'handled',\n      contentOffset: {\n        x: this.props.initialPage * this.state.containerWidth\n      },\n      ref: function ref(scrollView) {\n        _this3.scrollView = scrollView;\n      },\n      onScroll: function onScroll(e) {\n        var offsetX = e.nativeEvent.contentOffset.x;\n        _this3._updateScrollValue(offsetX / _this3.state.containerWidth);\n      },\n      onMomentumScrollBegin: this._onMomentumScrollBeginAndEnd,\n      onMomentumScrollEnd: this._onMomentumScrollBeginAndEnd,\n      scrollEventThrottle: 16,\n      scrollsToTop: false,\n      showsHorizontalScrollIndicator: false,\n      scrollEnabled: !this.props.locked,\n      directionalLockEnabled: true,\n      alwaysBounceVertical: false,\n      keyboardDismissMode: 'on-drag'\n    }, this.props.contentProps, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 182\n      }\n    }), scenes);\n  },\n  _composeScenes: function _composeScenes() {\n    var _this4 = this;\n    return this._children().map(function (child, idx) {\n      var key = _this4._makeSceneKey(child, idx);\n      return React.createElement(SceneComponent, {\n        key: child.key,\n        shouldUpdated: _this4._shouldRenderSceneKey(idx, _this4.state.currentPage),\n        style: {\n          width: _this4.state.containerWidth\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 217\n        }\n      }, _this4._keyExists(_this4.state.sceneKeys, key) ? child : React.createElement(View, {\n        heading: child.props.heading,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 228\n        }\n      }));\n    });\n  },\n  _onMomentumScrollBeginAndEnd: function _onMomentumScrollBeginAndEnd(e) {\n    var offsetX = e.nativeEvent.contentOffset.x;\n    var page = Math.round(offsetX / this.state.containerWidth);\n    if (this.state.currentPage !== page) {\n      this._updateSelectedPage(page);\n    }\n  },\n  _updateSelectedPage: function _updateSelectedPage(nextPage) {\n    var localNextPage = nextPage;\n    if (typeof localNextPage === 'object') {\n      localNextPage = nextPage.nativeEvent.position;\n    }\n    var currentPage = this.state.currentPage;\n    this.updateSceneKeys({\n      page: localNextPage,\n      callback: this._onChangeTab.bind(this, currentPage, localNextPage)\n    });\n  },\n  _onChangeTab: function _onChangeTab(prevPage, currentPage) {\n    this.props.onChangeTab({\n      i: currentPage,\n      ref: this._children()[currentPage],\n      from: prevPage\n    });\n  },\n  _updateScrollValue: function _updateScrollValue(value) {\n    this.state.scrollValue.setValue(value);\n    this.props.onScroll(value);\n  },\n  _handleLayout: function _handleLayout(e) {\n    var _this5 = this;\n    var width = e.nativeEvent.layout.width;\n    if (!width || width <= 0 || Math.round(width) === Math.round(this.state.containerWidth)) {\n      return;\n    }\n    this.setState({\n      containerWidth: width\n    });\n    this.requestAnimationFrame(function () {\n      _this5.goToPage(_this5.state.currentPage);\n    });\n  },\n  _children: function _children() {\n    var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.children;\n    return React.Children.map(children, function (child) {\n      return child;\n    });\n  },\n  render: function render() {\n    var overlayTabs = this.props.tabBarPosition === 'overlayTop' || this.props.tabBarPosition === 'overlayBottom';\n    var tabBarProps = {\n      goToPage: this.goToPage,\n      tabs: this._children().map(function (child) {\n        return child.props.heading;\n      }),\n      tabStyle: this._children().map(function (child) {\n        return child.props.tabStyle;\n      }),\n      activeTabStyle: this._children().map(function (child) {\n        return child.props.activeTabStyle;\n      }),\n      textStyle: this._children().map(function (child) {\n        return child.props.textStyle;\n      }),\n      activeTextStyle: this._children().map(function (child) {\n        return child.props.activeTextStyle;\n      }),\n      tabHeaderStyle: this._children().map(function (child) {\n        return _lodash2.default.get(child.props.heading.props, 'style', undefined);\n      }),\n      disabled: this._children().map(function (child) {\n        return child.props.disabled;\n      }),\n      accessible: this._children().map(function (child) {\n        return child.props.accessible == false ? false : true || true;\n      }),\n      accessibilityLabel: this._children().map(function (child) {\n        return child.props.accessibilityLabel;\n      }),\n      activeTab: this.state.currentPage,\n      scrollValue: this.state.scrollValue,\n      containerWidth: this.state.containerWidth\n    };\n    if (this.props.tabBarBackgroundColor) {\n      tabBarProps.backgroundColor = this.props.tabBarBackgroundColor;\n    }\n    if (this.props.tabBarActiveTextColor) {\n      tabBarProps.activeTextColor = this.props.tabBarActiveTextColor;\n    }\n    if (this.props.tabBarInactiveTextColor) {\n      tabBarProps.inactiveTextColor = this.props.tabBarInactiveTextColor;\n    }\n    if (this.props.tabBarTextStyle) {\n      tabBarProps.textStyle = this.props.tabBarTextStyle;\n    }\n    if (this.props.tabBarUnderlineStyle) {\n      tabBarProps.underlineStyle = this.props.tabBarUnderlineStyle;\n    }\n    if (this.props.tabContainerStyle) {\n      tabBarProps.tabContainerStyle = this.props.tabContainerStyle;\n    }\n    if (overlayTabs) {\n      var _tabBarProps$style;\n      tabBarProps.style = (_tabBarProps$style = {\n        position: 'absolute',\n        left: 0,\n        right: 0\n      }, _defineProperty(_tabBarProps$style, this.props.tabBarPosition === 'overlayTop' ? 'top' : 'bottom', 0), _defineProperty(_tabBarProps$style, 'backgroundColor', 'rgba(255, 255, 255, 0.7)'), _tabBarProps$style);\n    }\n    return React.createElement(View, {\n      style: [styles.container, this.props.style],\n      onLayout: this._handleLayout,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 342\n      }\n    }, (this.props.tabBarPosition === 'top' || this.props.tabBarPosition === 'overlayTop') && this.renderTabBar(tabBarProps), this.renderScrollableContent(), (this.props.tabBarPosition === 'bottom' || this.props.tabBarPosition === 'overlayBottom') && this.renderTabBar(tabBarProps));\n  }\n});\nexports.default = ScrollableTabView;\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scrollableContentAndroid: {\n    flex: 1\n  }\n});","map":{"version":3,"mappings":"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","names":["React","require","Component","Dimensions","ReactNative","View","Animated","ScrollView","StyleSheet","Platform","SceneComponent","DefaultTabBar","ScrollableTabBar","ScrollableTabView","displayName","statics","propTypes","tabBarPosition","PropTypes","oneOf","initialPage","number","page","onChangeTab","func","onScroll","renderTabBar","any","style","ViewPropTypes","contentProps","object","scrollWithoutAnimation","bool","locked","prerenderingSiblingsNumber","getDefaultProps","getInitialState","currentPage","props","scrollValue","Value","containerWidth","get","width","sceneKeys","newSceneKeys","componentDidMount","scrollFn","_this","scrollView","state","setValue","InteractionManager","runAfterInteractions","scrollToTimer","setTimeout","scrollTo","x","animated","componentWillUnmount","clearTimeout","UNSAFE_componentWillReceiveProps","children","updateSceneKeys","goToPage","pageNumber","offset","y","callback","_onChangeTab","bind","cloneElement","__source","fileName","lineNumber","_ref$children","_ref$callback","newKeys","previousKeys","setState","_ref2$currentPage","_ref2$children","_children","forEach","child","idx","key","_this2","_makeSceneKey","_keyExists","_shouldRenderSceneKey","push","currentPageKey","numOfSibling","find","sceneKey","heading","renderScrollableContent","scenes","_composeScenes","horizontal","pagingEnabled","automaticallyAdjustContentInsets","keyboardShouldPersistTaps","contentOffset","ref","_this3","offsetX","e","nativeEvent","_updateScrollValue","onMomentumScrollBegin","_onMomentumScrollBeginAndEnd","onMomentumScrollEnd","scrollEventThrottle","scrollsToTop","showsHorizontalScrollIndicator","scrollEnabled","directionalLockEnabled","alwaysBounceVertical","keyboardDismissMode","map","_this4","shouldUpdated","Math","round","_updateSelectedPage","nextPage","localNextPage","position","prevPage","i","from","value","_handleLayout","layout","requestAnimationFrame","_this5","Children","render","overlayTabs","tabBarProps","tabs","tabStyle","activeTabStyle","textStyle","activeTextStyle","tabHeaderStyle","_","undefined","disabled","accessible","accessibilityLabel","activeTab","tabBarBackgroundColor","backgroundColor","tabBarActiveTextColor","activeTextColor","tabBarInactiveTextColor","inactiveTextColor","tabBarTextStyle","tabBarUnderlineStyle","underlineStyle","tabContainerStyle","left","right","styles","container","onLayout","create","flex","scrollableContentAndroid"],"sources":["D:\\Learn\\Nodejs\\PRM_SWD_Project\\mobile\\easy-shop\\node_modules\\native-base\\src\\basic\\Tabs\\index.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport createReactClass from 'create-react-class';\nimport _ from 'lodash';\nimport { InteractionManager, ViewPropTypes } from '../../utils';\nconst React = require('react');\nconst { Component } = React;\nconst ReactNative = require('react-native');\nconst {\n  Dimensions,\n  View,\n  Animated,\n  ScrollView,\n  StyleSheet,\n  Platform\n} = ReactNative;\n\nconst SceneComponent = require('./SceneComponent');\nconst { DefaultTabBar } = require('./DefaultTabBar');\nconst { ScrollableTabBar } = require('./ScrollableTabBar');\n\nconst ScrollableTabView = createReactClass({\n  statics: {\n    DefaultTabBar,\n    ScrollableTabBar\n  },\n\n  propTypes: {\n    tabBarPosition: PropTypes.oneOf([\n      'top',\n      'bottom',\n      'overlayTop',\n      'overlayBottom'\n    ]),\n    initialPage: PropTypes.number,\n    page: PropTypes.number,\n    onChangeTab: PropTypes.func,\n    onScroll: PropTypes.func,\n    renderTabBar: PropTypes.any,\n    style: ViewPropTypes.style,\n    contentProps: PropTypes.object,\n    scrollWithoutAnimation: PropTypes.bool,\n    locked: PropTypes.bool,\n    prerenderingSiblingsNumber: PropTypes.number\n  },\n\n  getDefaultProps() {\n    return {\n      tabBarPosition: 'top',\n      initialPage: 0,\n      page: -1,\n      onChangeTab: () => {},\n      onScroll: () => {},\n      contentProps: {},\n      scrollWithoutAnimation: false,\n      locked: false,\n      prerenderingSiblingsNumber: 0\n    };\n  },\n\n  getInitialState() {\n    return {\n      currentPage: this.props.initialPage,\n      scrollValue: new Animated.Value(this.props.initialPage),\n      containerWidth: Dimensions.get('window').width,\n      sceneKeys: this.newSceneKeys({ currentPage: this.props.initialPage })\n    };\n  },\n\n  componentDidMount() {\n    const scrollFn = () => {\n      if (this.scrollView) {\n        this.state.scrollValue.setValue(this.props.initialPage);\n      }\n    };\n    InteractionManager.runAfterInteractions(scrollFn);\n    // because of contentOffset is not working on Android\n    this.scrollToTimer = setTimeout(() => {\n      if (this.scrollView) {\n        this.scrollView.scrollTo({\n          x: this.props.initialPage * this.state.containerWidth,\n          animated: false\n        });\n      }\n    });\n  },\n\n  componentWillUnmount() {\n    if (this.scrollToTimer) {\n      clearTimeout(this.scrollToTimer);\n    }\n  },\n\n  UNSAFE_componentWillReceiveProps(props) {\n    if (props.children !== this.props.children) {\n      this.updateSceneKeys({\n        page: this.state.currentPage,\n        children: props.children\n      });\n    }\n\n    if (props.page >= 0 && props.page !== this.state.currentPage) {\n      this.goToPage(props.page);\n    }\n  },\n\n  goToPage(pageNumber) {\n    const offset = pageNumber * this.state.containerWidth;\n    if (this.scrollView) {\n      this.scrollView.scrollTo({\n        x: offset,\n        y: 0,\n        animated: !this.props.scrollWithoutAnimation\n      });\n    }\n\n    const currentPage = this.state.currentPage;\n    this.updateSceneKeys({\n      page: pageNumber,\n      callback: this._onChangeTab.bind(this, currentPage, pageNumber)\n    });\n  },\n\n  renderTabBar(props) {\n    if (this.props.renderTabBar === false) {\n      return null;\n    } else if (this.props.renderTabBar) {\n      return React.cloneElement(this.props.renderTabBar(props), props);\n    }\n    return <DefaultTabBar {...props} />;\n  },\n\n  updateSceneKeys({\n                    page,\n                    children = this.props.children,\n                    callback = () => {}\n                  }) {\n    const newKeys = this.newSceneKeys({\n      previousKeys: this.state.sceneKeys,\n      currentPage: page,\n      children\n    });\n    this.setState({ currentPage: page, sceneKeys: newKeys }, callback);\n  },\n\n  newSceneKeys({\n                 previousKeys = [],\n                 currentPage = 0,\n                 children = this.props.children\n               }) {\n    const newKeys = [];\n    this._children(children).forEach((child, idx) => {\n      const key = this._makeSceneKey(child, idx);\n      if (\n        this._keyExists(previousKeys, key) ||\n        this._shouldRenderSceneKey(idx, currentPage)\n      ) {\n        newKeys.push(key);\n      }\n    });\n    return newKeys;\n  },\n\n  _shouldRenderSceneKey(idx, currentPageKey) {\n    const numOfSibling = this.props.prerenderingSiblingsNumber;\n    return (\n      idx < currentPageKey + numOfSibling + 1 &&\n      idx > currentPageKey - numOfSibling - 1\n    );\n  },\n\n  _keyExists(sceneKeys, key) {\n    return sceneKeys.find(sceneKey => key === sceneKey);\n  },\n\n  _makeSceneKey(child, idx) {\n    return `${child.props.heading}_${idx}`;\n  },\n\n  renderScrollableContent() {\n    const scenes = this._composeScenes();\n    return (\n      <ScrollView\n        horizontal\n        pagingEnabled\n        automaticallyAdjustContentInsets={false}\n        keyboardShouldPersistTaps=\"handled\"\n        contentOffset={{\n          x: this.props.initialPage * this.state.containerWidth\n        }}\n        ref={scrollView => {\n          this.scrollView = scrollView;\n        }}\n        onScroll={e => {\n          const offsetX = e.nativeEvent.contentOffset.x;\n          this._updateScrollValue(offsetX / this.state.containerWidth);\n        }}\n        onMomentumScrollBegin={this._onMomentumScrollBeginAndEnd}\n        onMomentumScrollEnd={this._onMomentumScrollBeginAndEnd}\n        scrollEventThrottle={16}\n        scrollsToTop={false}\n        showsHorizontalScrollIndicator={false}\n        scrollEnabled={!this.props.locked}\n        directionalLockEnabled\n        alwaysBounceVertical={false}\n        keyboardDismissMode=\"on-drag\"\n        {...this.props.contentProps}\n      >\n        {scenes}\n      </ScrollView>\n    );\n  },\n\n  _composeScenes() {\n    return this._children().map((child, idx) => {\n      const key = this._makeSceneKey(child, idx);\n      return (\n        <SceneComponent\n          key={child.key}\n          shouldUpdated={this._shouldRenderSceneKey(\n            idx,\n            this.state.currentPage\n          )}\n          style={{ width: this.state.containerWidth }}\n        >\n          {this._keyExists(this.state.sceneKeys, key) ? (\n            child\n          ) : (\n            <View heading={child.props.heading} />\n          )}\n        </SceneComponent>\n      );\n    });\n  },\n\n  _onMomentumScrollBeginAndEnd(e) {\n    const offsetX = e.nativeEvent.contentOffset.x;\n    const page = Math.round(offsetX / this.state.containerWidth);\n    if (this.state.currentPage !== page) {\n      this._updateSelectedPage(page);\n    }\n  },\n\n  _updateSelectedPage(nextPage) {\n    let localNextPage = nextPage;\n    if (typeof localNextPage === 'object') {\n      localNextPage = nextPage.nativeEvent.position;\n    }\n\n    const currentPage = this.state.currentPage;\n    this.updateSceneKeys({\n      page: localNextPage,\n      callback: this._onChangeTab.bind(this, currentPage, localNextPage)\n    });\n  },\n\n  _onChangeTab(prevPage, currentPage) {\n    this.props.onChangeTab({\n      i: currentPage,\n      ref: this._children()[currentPage],\n      from: prevPage\n    });\n  },\n\n  _updateScrollValue(value) {\n    this.state.scrollValue.setValue(value);\n    this.props.onScroll(value);\n  },\n\n  _handleLayout(e) {\n    const { width } = e.nativeEvent.layout;\n\n    if (\n      !width ||\n      width <= 0 ||\n      Math.round(width) === Math.round(this.state.containerWidth)\n    ) {\n      return;\n    }\n    this.setState({ containerWidth: width });\n    this.requestAnimationFrame(() => {\n      this.goToPage(this.state.currentPage);\n    });\n  },\n\n  _children(children = this.props.children) {\n    return React.Children.map(children, child => child);\n  },\n\n  render() {\n    const overlayTabs =\n      this.props.tabBarPosition === 'overlayTop' ||\n      this.props.tabBarPosition === 'overlayBottom';\n    const tabBarProps = {\n      goToPage: this.goToPage,\n      tabs: this._children().map(child => child.props.heading),\n      tabStyle: this._children().map(child => child.props.tabStyle),\n      activeTabStyle: this._children().map(child => child.props.activeTabStyle),\n      textStyle: this._children().map(child => child.props.textStyle),\n      activeTextStyle: this._children().map(\n        child => child.props.activeTextStyle\n      ),\n      tabHeaderStyle: this._children().map(child =>\n        _.get(child.props.heading.props, 'style', undefined)\n      ),\n      disabled: this._children().map(child => child.props.disabled),\n      accessible: this._children().map(child => child.props.accessible==false ? false : true || true ),\n      accessibilityLabel: this._children().map(child => child.props.accessibilityLabel),\n      activeTab: this.state.currentPage,\n      scrollValue: this.state.scrollValue,\n      containerWidth: this.state.containerWidth\n    };\n\n    if (this.props.tabBarBackgroundColor) {\n      tabBarProps.backgroundColor = this.props.tabBarBackgroundColor;\n    }\n    if (this.props.tabBarActiveTextColor) {\n      tabBarProps.activeTextColor = this.props.tabBarActiveTextColor;\n    }\n    if (this.props.tabBarInactiveTextColor) {\n      tabBarProps.inactiveTextColor = this.props.tabBarInactiveTextColor;\n    }\n    if (this.props.tabBarTextStyle) {\n      tabBarProps.textStyle = this.props.tabBarTextStyle;\n    }\n    if (this.props.tabBarUnderlineStyle) {\n      tabBarProps.underlineStyle = this.props.tabBarUnderlineStyle;\n    }\n    if (this.props.tabContainerStyle) {\n      tabBarProps.tabContainerStyle = this.props.tabContainerStyle;\n    }\n    if (overlayTabs) {\n      tabBarProps.style = {\n        position: 'absolute',\n        left: 0,\n        right: 0,\n        [this.props.tabBarPosition === 'overlayTop' ? 'top' : 'bottom']: 0,\n        backgroundColor: 'rgba(255, 255, 255, 0.7)'\n      };\n    }\n\n    return (\n      <View\n        style={[styles.container, this.props.style]}\n        onLayout={this._handleLayout}\n      >\n        {(this.props.tabBarPosition === 'top' ||\n          this.props.tabBarPosition === 'overlayTop') &&\n        this.renderTabBar(tabBarProps)}\n        {this.renderScrollableContent()}\n        {(this.props.tabBarPosition === 'bottom' ||\n          this.props.tabBarPosition === 'overlayBottom') &&\n        this.renderTabBar(tabBarProps)}\n      </View>\n    );\n  }\n});\n\nexport default ScrollableTabView;\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scrollableContentAndroid: {\n    flex: 1\n  }\n});\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}